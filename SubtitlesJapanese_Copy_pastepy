import os
import re
import sys
import time
import json
import bisect
from typing import List, Optional

import srt
import pyautogui
from pynput.mouse import Button, Listener
from pynput.keyboard import Key, Listener as KeyboardListener
import chardet

import tkinter as tk
from tkinter import filedialog, font as tkFont


class SubtitlePlayer:

    CLEAN_PATTERN_1 = re.compile(r'\{\\an\d+\}')
    CLEAN_PATTERN_2 = re.compile(r'[ï¼ˆ(].*?[ï¼‰)]')

    def __init__(self) -> None:
        srt_path_debug = config['DEBUGGING']
        print(srt_path_debug)
        self.srt_path = config['DEBUG_SRT_FILE'] if srt_path_debug else self.prompt_srt_file()
        if not self.srt_path: sys.exit(0)

        self.srt_dir = os.path.dirname(self.srt_path)
        self._srt_file_list = [
            f for f in os.listdir(self.srt_dir)
            if f.lower().endswith('.srt')]
        self.subtitles: List[srt.Subtitle] = self.load_subtitles(self.srt_path)
        self.cleaned_subtitles = [self._clean_text(sub.content) for sub in self.subtitles]
        self.total_duration: float = self.get_total_duration()
        self.start_times: List[float] = [sub.start.total_seconds() for sub in self.subtitles]
        self.subtitle_color = config['SUBTITLE_COLOR']

        self.root = tk.Tk()
        self.root.title("Subtitle Player Settings")
        self.root.geometry("330x130")
        self.root.minsize(340, 130)
        self.root.configure(bg="#f0f0f0")
        self.subtitle_font = tkFont.Font(family=config['SUBTITLE_FONT'], size=config['SUBTITLE_FONT_SIZE'], weight="bold")
        self.line_height = self.subtitle_font.metrics("linespace")
        self.max_width = self.measure_max_subtitle_width()

        self.current_time: float = config['DEFAULT_START_TIME']
        self.user_offset: float = 0.0
        self.last_update: float = time.time()
        self.hide_delay: int = config['CONTROL_HIDE_DELAY_MS']
        self.disappear_timer: int = config['CONTROL_DISAPPEAR_DELAY_MS']
        self.last_subtitle_text: str = ""
        self.subtitle_timeout_job: Optional[str] = None
        self.hide_controls_job: Optional[str] = None
        self.control_hide_timer_job: Optional[str] = None
        self.alt_reset_done: bool = False
        self.user_hidden: bool = False
        self.slider_dragging: bool = False
        self.user_hidden: bool = False
        self.mouse_over_controls: bool = False
        self.mouse_over_subtitles: bool = False
        self.playing: bool = False
        self.time_editing: bool = False
        self.video_click: bool = config['VIDEO_CLICK']
        self.use_phone_mode = tk.BooleanVar(value=False)
        self.init_settings_window()
        self.init_subtitle_window()
        self.init_control_window()
        self.bind_mouse_events()
        self.update_phone_mode_ui()
        self.control_window.attributes("-topmost", True)
        self.play_pause_button.config(text="Play", bg="green", font = "bold", activebackground="green")

        self.global_mouse_listener = Listener(on_click=self.on_global_click)
        self.global_mouse_listener.start()
        self.alt_pressed = False
        self.keyboard_listener = KeyboardListener(
            on_press=self._on_key_press,
            on_release=self._on_key_release)
        self.keyboard_listener.start()

        # self.root.after(0, self.toggle_play)
        self.root.after(config['UPDATE_INTERVAL_MS'], self.update_loop)
    
    # ---------- File & Subtitles Loading ----------
    def _on_key_press(self, key):
        if key in (Key.alt_l, Key.alt_r):
            self.alt_pressed = True
        elif hasattr(key, "char") and key.char and key.char.lower() == "x" and self.alt_pressed:
            self.on_alt_x()
        elif hasattr(key, "char") and key.char and key.char.lower() == "c" and self.alt_pressed:
            self.on_alt_c()
        elif hasattr(key, "char") and key.char and key.char.lower() == "y" and self.alt_pressed:
            self.on_alt_y()

    def _on_key_release(self, key):
        if key in (Key.alt_l, Key.alt_r):
            self.alt_pressed = False


    def on_alt_x(self, event=None):
        self.control_window.attributes("-topmost", True)
    def on_alt_c(self, event=None):
        self.increment_episode()
    def on_alt_y(self, event=None):
        self.decline_episode()

    def prompt_srt_file(self) -> Optional[str]:
        window = tk.Tk()
        window.attributes("-topmost", True)
        window.withdraw()
        file = filedialog.askopenfilename(parent=window,title="Select SRT File",filetypes=[("SubRip files", "*.srt"), ("All Files", "*.*")])
        window.destroy()
        return file





    def measure_max_subtitle_width(self) -> int:
        return max(
            self.subtitle_font.measure(line)
            for text in self.cleaned_subtitles
            for line in text.splitlines())

    # ----- UI Initialization -----

    ############# SETTINGS Window ###############
    def init_settings_window(self) -> None:
        settings_frame = tk.LabelFrame(self.root)
        settings_frame.pack(fill="both", expand=True, padx=5, pady=5)

        options_frame = tk.Frame(settings_frame, bg="#f0f0f0")
        options_frame.grid(row=0, column=0, sticky="nw")

        # Offset entry.
        tk.Label(options_frame, text="Offset (sec):", font=("Arial", 12), bg="#f0f0f0")\
            .grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.offset_var = tk.StringVar(value="0.0")
        self.offset_entry = tk.Entry(options_frame, textvariable=self.offset_var, font=("Arial", 12), width=7)
        self.offset_entry.grid(row=0, column=1, padx=5, pady=5, sticky="w")

        # Skip entry.
        tk.Label(options_frame, text="Skip:", font=("Arial", 12), bg="#f0f0f0")\
            .grid(row=0, column=2, padx=5, pady=5, sticky="e")
        self.skip_entry = tk.Entry(options_frame, font=("Arial", 12), width=7)
        self.skip_entry.insert(0, str(config['DEFAULT_SKIP']))
        self.skip_entry.grid(row=0, column=3, padx=5, pady=5, sticky="w")
        self.skip_entry.bind("<FocusOut>", lambda e: self.format_skip_entry())

        phone_episode_frame = tk.Frame(options_frame, bg="#f0f0f0")
        phone_episode_frame.grid(row=1, column=0, padx=5, pady=5, sticky="w")

        # Phone mode toggle button.
        self.mode_toggle_button = tk.Button(
            phone_episode_frame,
            text="ðŸ“ž",
            #font=("bold"),
            width=1, height=1,
            relief="raised",
            command=self.toggle_phone_mode
        )
        self.mode_toggle_button.pack(side="left", padx=(0,6))
                                     
        # Episode entry.
        tk.Label(
            phone_episode_frame,
            text="Episode:",
            font=("Arial", 12),
            bg="#f0f0f0"
        ).pack(side="left")

        episode_frame = tk.Frame(options_frame, bg="#f0f0f0")
        episode_frame.grid(row=1, column=1, padx=5, pady=0, sticky="w")
        # Episode entry inside the frame
        self.episode_var = tk.StringVar()
        match = re.search(r'E(\d+)', self.srt_path) # type: ignore
        self.episode_var.set(match.group(1) if match else "1")
        self.episode_entry = tk.Entry(episode_frame, textvariable=self.episode_var, font=("Arial", 12), width=4)
        self.episode_entry.pack(side="left")
        self.episode_entry.bind("<Return>", lambda e: self.on_episode_change())
        
        # Minus and Plus button next to the entry
        minus_button = tk.Button(episode_frame, text="-", font=("Arial", 8, "bold"), width=1,height=1, command=self.decline_episode)
        minus_button.pack(side="left")
        plus_button = tk.Button(episode_frame, text="+", font=("Arial", 8, "bold"), width=1,height=1, command=self.increment_episode)
        plus_button.pack(side="left")

        # "Set to" entry.
        tk.Label(options_frame, text="Set to:", font=("Arial", 12), bg="#f0f0f0")\
            .grid(row=1, column=2, padx=5, pady=0, sticky="e")
        self.setto_entry = tk.Entry(options_frame, font=("Arial", 12), width=7)
        self.setto_entry.grid(row=1, column=3, padx=5, pady=5, sticky="w")
        self.setto_entry.bind("<Return>", lambda e: self.set_to_time())
        
        # # Time slider.
        self.slider = tk.Scale(
            settings_frame,
            from_=0,
            to=self.total_duration,
            orient="horizontal",
            length=self.total_duration // 4.6,
            resolution=0.1,
            showvalue=1,
            command=self.on_slider_change,
            bg="#f0f0f0"
        )
        self.slider.grid(row=1, column=0, padx=0, pady=0, sticky="ew")
        self.slider.bind("<ButtonPress-1>", self.on_slider_press)
        self.slider.bind("<ButtonRelease-1>", self.on_slider_release)
        self.slider.set(config['DEFAULT_START_TIME'])

        formatted = self.format_time(config['DEFAULT_START_TIME'])
        self.time_overlay = tk.Label(settings_frame, text=formatted, font=("Arial", 9), bg="#f0f0f0")
        relx = config['RATIO'] + (1 - 2 * config['RATIO']) * (config['DEFAULT_START_TIME'] / self.total_duration)
        self.time_overlay.place(in_=self.slider, relx=relx, rely=0.2, anchor="center")
    
    
    ############# SUBTITLES Window ###############
    
    def init_subtitle_window(self) -> None:
        self.sub_window = tk.Toplevel(self.root)
        self.sub_window.overrideredirect(True)
        self.sub_window.attributes("-topmost", True)
        sw, sh = self.root.winfo_screenwidth(), self.root.winfo_screenheight()
        init_height = self.line_height * 2
        pos_x = (sw - self.max_width) // 2
        pos_y = sh - init_height - 215
        self.sub_window.geometry(f"{self.max_width}x{init_height}+{pos_x}+{pos_y}")
        self.sub_window.attributes("-transparentcolor", "grey")
        self.sub_window_bottom_anchor = pos_y + init_height

        self.border_frame = tk.Frame(self.sub_window, bg="grey")
        self.border_frame.pack(fill="both", expand=True)
        self.subtitle_canvas = tk.Canvas(self.border_frame, bg="grey", highlightthickness=0)
        self.subtitle_canvas.pack(fill="both", expand=True)
        self.subtitle_canvas.bind("<Button-3>", self.open_copy_popup)  

        drag_w, drag_h = 60, init_height
        self.handle_win = tk.Toplevel(self.root)
        self.handle_win.attributes("-topmost", True)
        self.handle_win.overrideredirect(True)
        is_phone_mode = self.use_phone_mode.get() if hasattr(self, 'use_phone_mode') else False
        self.handle_win.attributes("-alpha", 0.05 if is_phone_mode else 0.0)
        self.handle_win.geometry(f"{drag_w}x{drag_h}+{pos_x}+{pos_y}")
        self.make_draggable(self.handle_win, self.sub_window, sync_windows=[self.handle_win]) # type: ignore

        self.make_draggable(self.sub_window, self.sub_window) # type: ignore


    ############# CONTROL Window ###############

    def init_control_window(self) -> None:
        self.control_window = tk.Toplevel(self.root)
        self.control_window.overrideredirect(True)

        is_phone_mode = self.use_phone_mode.get() if hasattr(self, 'use_phone_mode') else False
        cw = 180 if not is_phone_mode else config.get('CONTROL_WINDOW_WIDTH')
        ch = 40 if not is_phone_mode else config.get('CONTROL_WINDOW_HEIGHT')

        sh = self.root.winfo_screenheight()
        pos_x = config['CONTROL_WINDOW_X']  #110
        base_y = config['CONTROL_WINDOW_Y'] #1000
        offset = 40 - ch  # Move up if ch is larger
        pos_y = base_y + offset if ch != 40 else base_y  
        self.control_window.geometry(f"{cw}x{ch}+{pos_x}+{pos_y}")

        main_frame = tk.Frame(self.control_window, bg="black")
        main_frame.pack(fill="both", expand=True)
        main_frame.columnconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=2)
        main_frame.columnconfigure(2, weight=1)
        main_frame.rowconfigure(0, weight=1)
        main_frame.rowconfigure(1, weight=1)

        self.back_button = tk.Button(main_frame, text="<< Skip", font=("Arial", 12, "bold"),
                                      command=self.go_back, width=6, height=2, bg="#3582B5", activebackground="#42A1E0", relief="flat")
        self.back_button.grid(row=0, column=0, rowspan=2, sticky="nsew")
        self.forward_button = tk.Button(main_frame, text="Skip >>", font=("Arial", 12, "bold"),
                                        command=self.go_forward, width=6, height=2, bg="#3582B5", activebackground="#42A1E0", relief="flat")
        self.forward_button.grid(row=0, column=2, rowspan=2, sticky="nsew")

        formatted = self.format_time(config['DEFAULT_START_TIME'])
        self.play_time_var = tk.StringVar(value=formatted)
        self.play_time_entry = tk.Entry(main_frame, textvariable=self.play_time_var,
                                        font=("Arial", 14, "bold"),
                                        bg="black", fg="white", width=6, justify="center")
        self.play_time_entry.grid(row=0, column=1, sticky="nsew")

        # self.play_time_entry.bind("<FocusIn>", self.on_time_entry_focus_in)
        self.play_time_entry.bind("<Return>", self.on_time_entry_return)
        # self.play_time_entry.bind("<FocusOut>", self.on_time_entry_focus_out)
        self.play_time_entry.bind("<Button-1>", self.clear_time_entry)

        self.play_pause_button = tk.Button(main_frame, text="Play", font=("Arial", 12),
                                           command=self.toggle_play, height=1, relief="flat")
        self.play_pause_button.grid(row=1, column=1, sticky="nsew")

        self.back_button.bind("<ButtonPress>", self.force_update_entry)
        self.forward_button.bind("<ButtonPress>", self.force_update_entry)
        self.play_pause_button.bind("<ButtonPress>", self.force_update_entry)

        self.control_drag_handle = tk.Frame(self.control_window, bg="gray", width=10, height=10)
        self.control_drag_handle.place(x=0, y=0)
        self.control_drag_handle.lift()
        self.make_draggable(self.control_drag_handle, self.control_window)

    # ---------- Event Handlers & Utility Methods ----------

    def toggle_phone_mode(self):
        self.use_phone_mode.set(not self.use_phone_mode.get())
        self.update_phone_mode_ui()

    def update_phone_mode_ui(self):
        is_phone_mode = self.use_phone_mode.get()
        self.mode_toggle_button.configure(bg="green" if is_phone_mode else "SystemButtonFace")
        self.control_window.attributes("-topmost", True)
        if hasattr(self, 'control_window') and self.control_window.winfo_exists():
            new_width = 180 if not is_phone_mode else config.get('CONTROL_WINDOW_WIDTH')
            new_height = 40 if not is_phone_mode else config.get('CONTROL_WINDOW_HEIGHT')
            pos_x = config['CONTROL_WINDOW_X']
            base_y = config['CONTROL_WINDOW_Y']
            offset = 40 - new_height
            pos_y = base_y + offset if new_height != 40 else base_y
            self.control_window.geometry(f"{new_width}x{new_height}+{pos_x}+{pos_y}")
        if hasattr(self, 'handle_win') and self.handle_win.winfo_exists():
            self.handle_win.attributes("-alpha", 0.05 if is_phone_mode else 0.0)

    def on_time_entry_focus_in(self, event) -> None:
        self.time_editing = True
        self.play_time_entry.delete(0, tk.END)
    def on_time_entry_return(self, event) -> None:
        self.commit_time_entry_change()
        self.time_editing = False
        self.force_update_entry()
    def on_time_entry_focus_out(self, event) -> None:
        if self.time_editing:
            self.play_time_var.set(self.format_time(self.current_time))
            self.time_editing = False
    def clear_time_entry(self, event) ->None:
        self.time_editing = True
        event.widget.delete(0, tk.END)
    def commit_time_entry_change(self) -> None:
        content = self.play_time_var.get().strip()
        if content == "":
            self.play_time_var.set(self.format_time(self.current_time))
            return
        try:
            new_time = self.parse_time_value(content)
            self.set_current_time(new_time)
        except Exception:
            pass
        self.play_time_var.set(self.format_time(self.current_time))

    def force_update_entry(self, event=None) -> None:
        self.play_time_var.set(self.format_time(self.current_time))
    def set_to_time(self) -> None:
        new_time = self.parse_time_value(self.setto_entry.get())
        self.set_current_time(new_time)
        self.setto_entry.delete(0, tk.END)
        self.root.focus_set()




    # ----- Mouse and Drag Handlers -----

    def bind_mouse_events(self) -> None:
        for widget in [self.sub_window, self.border_frame]:
            widget.bind("<Enter>", self.on_sub_enter)
            widget.bind("<Leave>", self.on_sub_leave)
        self.control_window.bind("<Enter>", self.on_controls_enter)
        self.control_window.bind("<Leave>", self.on_controls_leave)
        self.control_window.bind("<Motion>", self.on_controls_enter)
        self.sub_window.bind("<Enter>", self.subtitle_hover_enter)
        self.sub_window.bind("<Leave>", self.subtitle_hover_leave)

    def on_controls_enter(self, event):
        self.set_mouse_over("controls", True)
    def on_controls_leave(self, event):
        self.set_mouse_over("controls", False)

    def on_sub_enter(self, event):
        self.set_mouse_over("subtitles", True)
    def on_sub_leave(self, event):
        self.set_mouse_over("subtitles", False)

    def lower_controls(self) -> None:
        self.control_window.lower()
        self.hide_controls_job = None


    # ----- Time & Subtitle Updates -----

    def update_debug_srt_file_in_config(new_season: int, new_episode: int, config_path: str = "config.json") -> None:
        # Read the current configuration
        with open(config_path, "r", encoding="utf-8") as f:
            config_data = json.load(f)
        
        debug_srt_file = config_data.get("DEBUG_SRT_FILE", "")

        def replace_season_episode(match):
            # Preserve the zero-padding based on the original file name parts
            season_str = str(new_season).zfill(len(match.group(1)))
            episode_str = str(new_episode).zfill(len(match.group(2)))
            return f"S{season_str}E{episode_str}"
        
        # Look for a pattern like S01E05 in the file name
        new_debug_srt_file = re.sub(r'S(\d+)E(\d+)', replace_season_episode, debug_srt_file, count=1)
        config_data["DEBUG_SRT_FILE"] = new_debug_srt_file

        with open(config_path, "w", encoding="utf-8") as f:
            json.dump(config_data, f, indent=4, ensure_ascii=False)




    def _load_new_srt(self, filename: str, season: int, episode: int) -> None:
        new_path = os.path.join(self.srt_dir, filename)
        self.srt_path = new_path
        self.subtitles = self.load_subtitles(new_path)
        self.cleaned_subtitles = [self._clean_text(s.content) for s in self.subtitles]
        self.total_duration = self.get_total_duration()
        self.start_times = [s.start.total_seconds() for s in self.subtitles]

        # reset slider/time
        self.slider.config(to=self.total_duration)
        self.current_time = config['DEFAULT_START_TIME']
        self.slider.set(config['DEFAULT_START_TIME'])
        self.update_time_displays()
        self.update_subtitle_display()

        # update episode entry and debug config
        self.episode_var.set(str(episode))
        update_debug_srt_file_in_config(new_season=season, new_episode=episode + 1)
        self.sub_window.focus_force()

    def set_current_time(self, new_time: float) -> None:
        self.current_time = max(0.0, min(new_time, self.total_duration))
        self.last_update = time.time()
        self.slider.set(self.current_time)
        self.update_time_displays()
        self.update_subtitle_display()

    def update_subtitle_display(self) -> None:
        self.user_offset = float(self.offset_var.get())
        effective_time = self.current_time - (self.user_offset + config['EXTRA_OFFSET'])
        index = bisect.bisect_right(self.start_times, effective_time) - 1
        new_text = self.cleaned_subtitles[index] if index >= 0 else ""
        if new_text == self.last_subtitle_text and self.user_hidden:
            return
        if new_text != self.last_subtitle_text:
            if self.subtitle_timeout_job is not None:
                self.root.after_cancel(self.subtitle_timeout_job)
                self.subtitle_timeout_job = None
            self.last_subtitle_text = new_text                
            self.user_hidden = False
            self._render_subtitle(new_text)

        # schedule hide
        if self.playing and not self.subtitle_timeout_job:
            self.subtitle_timeout_job = self.root.after(
                config['SUBTITLE_TIMEOUT_MS'],
                self.hide_subtitles_temporarily
            )

    def reformat_time_entry(self, entry: tk.Entry) -> None:
        seconds_val = self.parse_time_value(entry.get())
        minutes, seconds = divmod(int(seconds_val), 60)
        formatted = f"{minutes:02d}:{seconds:02d}"
        entry.delete(0, tk.END)
        entry.insert(0, formatted)

    def format_skip_entry(self) -> None:
        self.reformat_time_entry(self.skip_entry)


    def on_subtitle_click(self, event: tk.Event) -> None:
        self.user_hidden = not self.user_hidden
        if self.user_hidden:
            self.subtitle_canvas.delete("all")
    def schedule_hide_controls(self) -> None:
        is_phone_mode = self.use_phone_mode.get() if hasattr(self, 'use_phone_mode') else False
        if is_phone_mode:
            if self.control_hide_timer_job is not None:
                self.root.after_cancel(self.control_hide_timer_job)
            self.control_hide_timer_job = self.root.after(self.disappear_timer, self.lower_controls)

